@using Sandbox.UI
@using Facepunch.Gunfight.UI

@namespace Facepunch.Gunfight.MainMenu
@inherits BaseModal
@attribute [StyleSheet]

<root>
    <div class="main">
        <div class="title">
            @ClassName
        </div>

        @if ( Weapon is null )
        {
            <div class="options">
                <ActionButton onclick=@( () => Select( CustomClass.PrimaryWeapon ) )>
                    <Title>@CustomClass.PrimaryWeapon.Name</Title>
                </ActionButton>
                <ActionButton onclick=@( () => Select( CustomClass.SecondaryWeapon ) )>
                    <Title>@CustomClass.SecondaryWeapon.Name</Title>
                </ActionButton>
            </div>

            <div class="options">
                <ActionButton onclick=@( () => Save() )>
                    <Title>Save</Title>
                </ActionButton>
                <ActionButton onclick=@( () => Delete() )>
                    <Title>Delete</Title>
                </ActionButton>
            </div>
        }
        else
        {
            <div class="weapon-view">
                <WeaponViewer @ref="WeaponViewer" />
            </div>

            <div class="attachment-slots">

                @foreach ( var group in WeaponAttachment.For( Weapon.Name ).GroupBy( x => x.Category ) )
                {
                    @foreach ( var attachment in group )
                    {
                        <div class="slot @( AttachmentClass( attachment ) )" onclick=@(() => ToggleAttachment( attachment ) )>
                            <label class="group">@group.Key</label>
                            <label>@attachment.Name</label>
                        </div>
                    }
                }
            </div>

            <ActionButton onclick=@( () => Return() )>
                <Title>Return</Title>
            </ActionButton>
        }
    </div>
</root>


@code
{
    public string ClassName { get; set; }
    public WeaponViewer WeaponViewer { get; set; }

    public Action OnSave;

    public Gunfight.CreateAClass.CustomClass CustomClass { get; set; }

    public Gunfight.CreateAClass.Weapon Weapon { get; set; }

    public void Save()
    {
        OnSave?.Invoke();
    }

    void Return()
    {
        Weapon = null;
    }

    public void Select( Gunfight.CreateAClass.Weapon wpn )
    {
        Weapon = wpn;
        StateHasChanged();
    }

    public void Delete()
    {
    }

    string AttachmentClass( WeaponAttachment att )
    {
        if ( Weapon.Attachments.Contains( att.Identifier ) ) return "active";

        return "";
    }

    public void ToggleAttachment( WeaponAttachment att )
    {
        if ( Weapon.Attachments.Contains( att.Identifier ) )
        {
            Weapon.Attachments.Remove( att.Identifier );
        }
        else
        {
            Weapon.Attachments.Add( att.Identifier );
        }

        Refresh();
    }

    public void Refresh()
    {
        if ( WeaponViewer is null ) return;

        // THIS IS TEMPORARY
        // REPLACE THIS WITH REAL DATA

        if ( Weapon.Name == "mp5" )
        {
            WeaponViewer.SetModel( Gunfight.MP5.MP5Model );
        }
        else
        {
            WeaponViewer.SetModel( Gunfight.USP.USPModel );
        }


        foreach ( var att in Weapon.Attachments.Select( x => WeaponAttachment.Get( x ) ).OrderBy( x => x.Priority ) )
        {
            att?.SetupSceneModel( WeaponViewer.Model );
        }
    }

    public ClassModal( string name, Gunfight.CreateAClass.CustomClass customClass, Action callback = null )
    {
        ClassName = name;
        CustomClass = customClass;
        OnSave = callback;
    }

    void Update()
    {
        if ( WeaponViewer is null ) return;

        var bounds = WeaponViewer.Model.Bounds;
        var middle = (bounds.Mins + bounds.Maxs) * 0.5f;

        var size = 0f;
        size = MathF.Max( size, MathF.Abs( bounds.Mins.x ) + MathF.Abs( bounds.Maxs.x ) );
        size = MathF.Max( size, MathF.Abs( bounds.Mins.y ) + MathF.Abs( bounds.Maxs.y ) );
        size = MathF.Max( size, MathF.Abs( bounds.Mins.z ) + MathF.Abs( bounds.Maxs.z ) );

        WeaponViewer.Camera.Position = Vector3.Right * -middle.y + Vector3.Up * middle.z + Vector3.Backward * ( 40f + ( size * 2f ) );
        WeaponViewer.Camera.FieldOfView = 23;
        WeaponViewer.Camera.ZNear = 5;
        WeaponViewer.Camera.ZFar = 15000;
        WeaponViewer.Camera.AmbientLightColor = Color.Gray * 0.5f;

        //We should be using the map fog but use this for now. - louie
        WeaponViewer.World.GradientFog.Enabled = true;
        WeaponViewer.World.GradientFog.Color = new Color(0.03f, 0.11f, 0.19f);
        WeaponViewer.World.GradientFog.MaximumOpacity = 0.28f;
        WeaponViewer.World.GradientFog.StartHeight = 0;
        WeaponViewer.World.GradientFog.EndHeight = 2000;
        WeaponViewer.World.GradientFog.DistanceFalloffExponent = 2;
        WeaponViewer.World.GradientFog.VerticalFalloffExponent = 0;
        WeaponViewer.World.GradientFog.StartDistance = 500;
        WeaponViewer.World.GradientFog.EndDistance = 1000;
    }

    protected override void OnAfterTreeRender( bool firstTime )
    {
        Refresh();
        Update();
    }
}
